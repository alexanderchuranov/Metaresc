<?xml version="1.0" encoding="utf-8"?>
 <article xmlns="http://docbook.org/ns/docbook"
       xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">

   <info>
     <title>
       METARESC Library User Guide
     </title>

     <author>
       <personname>
         <firstname>Alexander</firstname>
         <surname>Churanov</surname>
       </personname>
     </author>

     <copyright>
       <year>2012</year>
       <holder>Alexander Churanov</holder>
     </copyright>
   </info>

   <section xml:id="overview">
     <title>Overview</title>

     <para>
       METARESC is a software library written in C programming
       language. It allows declaring types using a special METARESC
       grammar. The variables of types declared that way may be
       subsequently serialized into various formats and deserialized
       later. To achieve this the library adds metadata annotations to
       types. These annotations may be used for may purposes far
       beyond just achieving the persistence.
     </para>
   </section>

   <section xml:id="distinctive">
     <title>Distinctive Features</title>

     <para>
       There are other solutions for data marshalling around. To make
       an intelligent choice you need to know how they all differ. The
       following is a list of features that are specific to METARESC.
     </para>

     <para>
       <itemizedlist>
         <listitem><para>
         Works with arbitrary types, structures of any complexity.
         </para></listitem>

         <listitem><para>
         Each type is described only once at the time of its declaration.  
         </para></listitem>

         <listitem><para>
         Supports multiple input/output formats.
         </para></listitem>

         <listitem><para>
         Exposes metadata, supports run-time introspection of types.
         </para></listitem>

         <listitem><para>
         Provides global registry of types and metadata-by-typename lookup.
         </para></listitem>

         <listitem><para>
         Fast compilation for code which uses the library.
         </para></listitem>

         <listitem><para>
         Reasonable CPU and memory consumption.
         </para></listitem>
       </itemizedlist>
     </para>
   </section>

   <section xml:id="general">
     <title>Getting Started</title>

     <section xml:id="obtaining">
       <title>How to get METARESC on your machine</title>

       <section>
         <title>What you need to use the library</title>
         <para>
           <itemizedlist>
             <listitem><para>
               Library headers and binary (static or dynamic) installed
             </para></listitem>

             <listitem><para>
               GNU C Compiler 4.2 or newer
             </para></listitem>
           </itemizedlist>
         </para>

         <para>
           At present the list of supported compilers is just a single
           item. This is because to provide all its features the library
           has to use very sophisticated language and run-time
           mechanisms. Porting the library to other compilers is a work
           in progress.
         </para>

         <para>
           Note, that now not only the library itself, but also its
           clients have to be written in C and compiled with the GCC.
         </para>
       </section>

       <section>
         <title>Installation</title>

         <section>
           <title>Installing from software repository</title>
           <para>
             It's recommended that you first check whether the pre-built
             package (or source port) exists in your operating system
             software repository. Installing from repository has several
             advantages:

             <itemizedlist>
               <listitem><para>
                 The library is already built with the appropriate options.
               </para></listitem>

               <listitem><para>
                 The library is installable in the appropriate place on
                 your system.
               </para></listitem>

               <listitem><para>
                 The package is likely to be tested by maintainer.
               </para></listitem>

               <listitem><para>
                 The package may have dependent packages that are
                 instantly testing METARESC package correctness.
               </para></listitem>

               <listitem><para>
                 It's faster.
               </para></listitem>
             </itemizedlist>
           </para>

           <para>
             At present the METARESC team does not maintain a package or
             port for any operating system. This is, however, much
             anticipated.
           </para>
         </section>

         <section>
           <title>Installing from source</title>
           <para>
             Installing from source may be helful in the following cases:
             <itemizedlist>
               <listitem><para>
                 You need custom compile-time options for the library.
               </para></listitem>

               <listitem><para>
                 There is no package that you can install.
               </para></listitem>

               <listitem><para>
                 You have to install the library into custom location.
               </para></listitem>

               <listitem><para>
                 You want to modify the source code. In this case,
                 please, respect the license.
               </para></listitem>
             </itemizedlist>
           </para>

           <para>
             To install the library from source you first need to obtain
             the code. This may be accomplished by checking the code out
             from the Git repository on Github. Use the following command
             to check out the code ("cloning" in Git lingo):
             <screen>git clone git://github.com/alexanderchuranov/Metaresc.git</screen>
           </para>

           <para>
             The build process of METARESC requires following software to
             be installed on your system:
             <itemizedlist>
               <listitem><para>Bison 2.4.3</para></listitem>
               <listitem><para>Flex 2.5.35</para></listitem>
               <listitem><para>Help2Man 1.39.2</para></listitem>
               <listitem><para>Libtool 2.4</para></listitem>
               <listitem><para>Autoconf 2.66 (optional)</para></listitem>
               <listitem><para>Automake 1.11.1 (optional)</para></listitem>
               <listitem><para>LibXML2 2.7.7 (optional)</para></listitem>
               <listitem><para>LibCheck 0.9.5 (optional)</para></listitem>
             </itemizedlist>
             The library is known to work with these versions of
             software. Newer software is also expected to work.
           </para>

           <para>
             Once you have the code it's time to configure and build the
             library. METARESC build is based on popular GNU Build System
             (a.k.a. "Autotools"), so you may already know what to do
             with it. The first step is configuration for your
             environment. This is what the <command>configure</command>
             script exists for. Most often it requires no arguments and
             finishes successfully. After this you may run
             <command>make</command> command, followed by <command>make
             install</command> to build and install the library
             respectively. All the steps may look like this:

             <screen>
 git clone git://github.com/alexanderchuranov/Metaresc.git
 cd Metaresc
 ./configure
 make
 make install </screen>
           </para>

           <para>
             At the configuration stage you may optionally specify various
             build and installation parameters. Most common are "prefix",
             allowing you to install into custom location, and "LEX",
             overriding the selection of a lexer. The latter is useful,
             for example, on FreeBSD, which has a flex in the base system
             and other in ports, and their versions differ
             dramatically. The following is an example of using
             configuration options:

             <screen>
 git clone git://github.com/alexanderchuranov/Metaresc.git
 cd Metaresc
 ./configure LEX=/usr/local/bin/flex prefix=/special/path
 make
 make install </screen>
           </para>
         </section>

         <section>
           <title>Running sample application</title>
           <para>
             The source package contains a sample application that uses
             the library and deserializes objects from the XML file. To
             run the program type the following commands:

             <screen><![CDATA[
 cd examples
 ./gjobs < gjobs.xml]]></screen>

             You should see an output like this:

             <screen><![CDATA[
 1 Jobs registered
 =======  Job
 projectID: 3
 application: GBackup
 category: Development
 ------ Person
         name: Nathan Clemons
         email: nathan@windsofstorm.net
         company: FooBar Software
         organisation: 

         smail: 321 Hillview Court, Somewhere-city, ZQ 54312, Zimbovia
         Web: web://foobarsoftware/
         phone: 011 4321 917 123 45 67
 ------
 1 developers
 ------ Person
 ------
 ======= ]]></screen>

             This indicates that the library is built successfully and
             may be used by applications.
           </para>
         </section>
       </section>
     </section>

     <section xml:id="building-clients">
       <title>Building client applications</title>

       <section>
         <title>Using the library in a simple way</title>
         <para>
           The easiest way to use a library is to include the
           <filename>metaresc.h</filename> header file and start
           declaring metadata-enabled types. You may include this
           header in a header file of your project, where the
           serializable data type is to be declared. Or you may include
           the header and your type declaration in some implementation
           file. The latter is illustrated by the following example:

           <programlisting language="c"><xi:include
           href="../../examples/basic.c"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
           /></programlisting>

           For this code sample to compile correctly you need to let
           the compiler know where to find METARESC headers and either
           static or dynamic library. For a Linux system this typically
           looks like this:

           <screen><![CDATA[
 cc -Ipath/to/metaresc/headers `xml2-config --cflags` -c -o basic.o basic.c
 cc -Lpath/to/metaresc/libs -lmetaresc `xml2-config --libs` -o basic basic.o ]]></screen>

           If the METARESC library is installed in /usr, as when
           installing from a pre-built package, then paths to the
           library may be omitted, since the compiler already knows it
           should look for headers in /usr/local and for libraries in
           /usr/lib:

           <screen><![CDATA[
 cc `xml2-config --cflags` -c -o basic.o basic.c
 cc -lmetaresc `xml2-config --libs` -o basic basic.o ]]></screen>

           Note, that in both cases options for libxml2 header files are
           also specified. This is only necessary if METARESC was built
           with libxml2 support (which is the default).
         </para>

         <para>
           The exact commands, of course, depend on the operating
           system and its configuration. On FreeBSD, for example,
           /usr/include and /usr/lib traditionally only contain files of the
           operating system and all third-party software gets installed
           in /usr/local. In this case you have to additionally specify
           /usr/local/include as a header search path and
           /usr/local/lib as a library search path. METARESC depends on
           some standard facilities, like iconv, which go into
           /usr/local on FreeBSD. The commands for this system may look
           like the following:

           <screen><![CDATA[
 cc `xml2-config --cflags` -I/usr/local/include -c -o basic.o basic.c
 cc -L/usr/local/lib -lmetaresc -o basic basic.o ]]></screen>
         </para>
         <!-- TODO: verify all command lines for Linuxen -->
         <para>
           The code sample above is extremely simplifed. Of course, the
           serializable type declarations may reside in their own
           header files, and there may be many of them, and some of
           them may be included into others, as necessary. This has no
           impact on the functionality of METARESC.
         </para>
       </section>

       <section>
         <title>Optimizing application start-up</title>
         <para>
           The "just include header file" approach, suggested in the
           previous section is convenient and suitable for many types
           of applications. It is the recommended way to use the
           library unless you have specific requirements for memory and
           CPU usage. Applications written in C language are likely to
           have such requirements. And this is why you may want to
           consider the other method of accessing the METARESC
           facilities from your program.
         </para>

         <para>
           When the <filename>metaresc.h</filename> header file is
           included into a client program, METARESC has to generate the
           following for each serializable type, declared within the
           translation unit:

           <itemizedlist>
             <listitem><para>
               Metadata, a structured set of data which describes the
               internals of the serializable type: how many fields
               there are in the structure, what their types are, what
               their names are, etc.
             </para></listitem>
             <listitem><para>
               Functions for registering the type in the
	       application-wide type registry.
             </para></listitem>
             <listitem><para>
               Standard type declaration, e.g. "typedef struct user_t {
               ...". Obviously, this is necessary for the program to
               manipulate the variables of that type.
             </para></listitem>
           </itemizedlist>

           The standard type declaration has no specific impact on the
           CPU and memory usage, since it is exactly the same you would
           declare if METARESC was not used. Metadata, however,
           occupies space in the executable file both on disk and in
           memory, when loaded. Functions for type registring
           not only also occupy space, but get executed when the
           application starts. This is necessary for building a global,
           application-wide type registry.
         </para>

         <para>
           So far, all this stuff is just necessary for successful
           serialization and deserialization of data. The things that
           may be undesirable are that all this generated stuff is
           added to <emphasis>each</emphasis> source file, which
           includes the header with serializable type declaration,
           either directly or via other headers.
         </para>

         <para>
           This happens because of two things. First, it is necessary
           to put metadata and functions into executable and to build
           the type registry upon program start. Second, the C language
           doesn't have a notion of "put to executable" — the
           stuff, generated by preprocessor out of header files, is
           just included into the source file. If the header is
           included in two files, there are two copies of metadata and
           related functions in the program.
         </para>

         <para>
           If this is a concern, you have to optimize the program. To
           assist in that, METARESC provides type registration
           optimization and a way to generate declarations separately
           from metadata stuff.
         </para>

         <para>
           Type registration optimization happens when the program
           starts building the type registry. The process of builing
           type registry occurs in a program which uses METARESC before
           the control is passed to the function
           <function>main</function>. During this phase special
           "start-up" METARESC code from each compiled source file,
           which includes library headers, is executed. If the same
           serializable type declaration is included into more than one
           source file, the code to register the same type may be
           called more than once. The library detects that the type is
           already registered and does not perform the registration
           again. This optimization is performed automatically and is
           not controlled by the client application.
         </para>

         <para>
           The most effect is however achieved when type declarations
           and metadata-related things are generated separately. The
           preprocessor metaprogram contained in library header files
           may be specifically instructed to generate either type
           declarations or metadata and related functions. For
           exploiting this, you need to define (or re-define) the
           <code>MR_MODE</code> macro. The macro may have following values:

           <informaltable>
             <tgroup cols="2" align="left" colsep="1" rowsep="1">
               <thead>
                 <row>
                   <entry>Value</entry>
                   <entry>Meaning</entry>
                 </row>
               </thead>
               <tbody>
                 <row>
                   <entry>PROTO</entry>
                   <entry>
                     Generate type declarations only. For all types,
                     declared later in the file using METARESC grammar,
                     only declarations will be generated. This provides
                     the ability to use the variables of declared
                     types, access their members, etc.
                   </entry>
                 </row>
                 <row>
                   <entry>DESC</entry>
                   <entry>
                     Generate metadata and related code, including type
                     registration code. This makes metadata available
                     both to the library and the program.
                   </entry>
                 </row>
               </tbody>
             </tgroup>
           </informaltable>
         </para>

         <para>
           The recommended way to use separatly generated declarations
           and metadata stuff is as follows:

           <orderedlist>
             <listitem><para>
               For each serializable type three files should exist: the
               "naked" header file with declarations, the "ordinary" header
               file and the "implementation" source file.
             </para></listitem>

             <listitem><para>
               In the "naked header file" include the
               <filename>metaresc.h</filename> library header and declare
               types using METARESC grammar. This file should not have
               any protection from incluing it multiple times.
             </para></listitem>

             <listitem><para>
               In the "ordinary" header file, specify the
               <code>MR_MODE</code> as <code>PROTO</code>, then include
               the "naked" header file. If you have functions that
               "implement" a serializable type, this header file is a
               natural place to put their declarations into.
             </para></listitem>

             <listitem><para>
               The "implementation" source file should include the
               "ordinary" header file, then unconditionally re-declare
               <code>MR_MODE</code> macro to <code>DESC</code> and
               include the "naked" header file with declarations. It's
               convenient to define functions that "implement" a
               serializable type in this source file.
             </para></listitem>

             <listitem><para>
               It is not necessary to create three files for each
               type. Types may be declared, for example, in groups or
               in any other way you see fit. The only mandatory thing
               about this is that for each serializable type there
               should be a file with declarations, a header file with
               protection against multiple inclusion and a compilable
               source file which includes "naked" declarations first
               with <code>PROTO</code> mode, then with
               <code>DESC</code> mode.
             </para></listitem>

             <listitem><para>
               The "ordinary" header files may be included in other
               application header and source files like any regular
               header file.
             </para></listitem>
           </orderedlist>
         </para>

         <para>
           The rules above are exemplified in the following code
           sample. First, the
           <filename>separate_employee_decl.h</filename> file with
           "naked" declarations:

           <programlisting language="c"><xi:include
           href="../../examples/separate_employee_decl.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
           /></programlisting>

           Then, the "ordinary" header file with proctection from
           multiple inclusion
           (<filename>separate_employee.h</filename>):

           <programlisting language="c"><xi:include
           href="../../examples/separate_employee.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
           /></programlisting>

           The "implementation" source file
           (<filename>separate_employee.c</filename>):

           <programlisting language="c"><xi:include
           href="../../examples/separate_employee.c"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
           /></programlisting>

           And, finally, the regular source file, which uses the
           <filename>separate_employee.h</filename> "ordinary" header
           file and contains the <function>main</function> function:

           <programlisting language="c"><xi:include
           href="../../examples/separate.c"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
           /></programlisting>
         </para>
       </section>
     </section>

   </section>
   
   <section xml:id="mem-mgmt">
     <title>Memory management</title>
     
     <para>
       The METARESC library may allocate memory on behalf of your
       application for many reasons. Loading variable-sized structures
       is the most obvious one. Since different applications have
       different requirements for memory management, METARESC is
       configurable in this respect and allows specifying memory
       management functions to use. If you don't explicitly configure
       the library, then the standard <code>malloc</code>,
       <code>realloc</code> and <code>free</code> are used.
     </para>
     
     <para>
       To make switching memory managers easier, METARESC provides
       three memory management macros: <code>MR_MALLOC</code>,
       <code>MR_REALLOC</code>, <code>MR_FREE</code> and <code>MR_STRDUP</code>.
       They are used
       as drop-in replacements for the <code>malloc</code>,
       <code>realloc</code>, <code>free</code> and <code>strdup</code>
       respectively. These
       macros always call memory management functions, which
       the library is configured to use. Using them in the code that
       works with serializable data structures is the recommended way
       to achieve consistency in managing memory.
     </para>
     
     <para>
       Memory management functions are stored in a global structure
       mr_conf of type mr_conf_t. This structure contains all library
       specific information. All four handlers are stored in a field
       mr_mem of type mr_mem_t. mr_mem_t and mr_conf_t both defined
       in a <filename>mr_protos.h</filename> header file. All
       library's types are defined
       on a library macro language. E.g. mr_mem_t is defined as follows:
        <programlisting language="c"><![CDATA[
TYPEDEF_STRUCT (mr_mem_t, ATTRIBUTES ( , "Metaresc memory operations"),
	(float, mem_alloc_strategy, , "memory allocation strategy"),
	(void *, malloc, (const char *, const char *, int, size_t), "pointer on malloc() function"),
	(void *, realloc, (const char *, const char *, int, void *, size_t), "pointer on realloc() function"),
	(char *, strdup, (const char *, const char *, int, const char *), "pointer on strdup() function"),
	(void, free, (const char *, const char *, int, void *), "pointer on free() function"),
	)
	]]></programlisting>
	First 3 arguments of those handlers are file name, function
	name and line number of the invocation place. Macro functions
	MR_MALLOC, MR_REALLOC, MR_FREE and MR_STRDUP are defined in
	a <filename>metaresc.h</filename> header file as follows:
        <programlisting language="c"><![CDATA[
	#define MR_MALLOC(SIZE) (mr_conf.mr_mem.malloc)(__FILE__, __FUNCTION__, __LINE__, SIZE)
	#define MR_REALLOC(PTR, SIZE) (mr_conf.mr_mem.realloc)(__FILE__, __FUNCTION__, __LINE__, PTR, SIZE)
	#define MR_STRDUP(STR) (mr_conf.mr_mem.strdup)(__FILE__, __FUNCTION__, __LINE__, STR)
	#define MR_FREE(PTR) (mr_conf.mr_mem.free)(__FILE__, __FUNCTION__, __LINE__, PTR)
	]]></programlisting>
     </para>
     
     <para>
       mr_mem_t has one more field - mem_alloc_strategy. This parameter
       is used for resizable arrays re-allocation strategy. This is ratio
       for array size re-allocation. By default it is equals to 2. This
       means that array size at least doubles on an additional arrays
       elements request.
     </para>

     <para>
       By default memory handling functions are stubbed as wrappers
       over standard LibC implementations. User can replace those
       handlers on a custom memory management solution. Due to the
       fact that library do some magic before execution of main (),
       there are some memory allocations before all users code execution.
       There is a way to redefine hooks at the very begging.
       Macro <code>MR_MEM_INIT()</code> do the trick. This macro is
       defined in a <filename>metaresc.h</filename> as follows:
       
       <programlisting language="c"><![CDATA[
       #define MR_MEM_INIT(FUNC, /* ATTR */ ...) __VA_ARGS__ void mr_mem_init (void) { FUNC; }
       ]]></programlisting>
       
       Macro can have from zero to three arguments. First one is a
       function that will be called before all other code. Second
       is an attribute for mr_mem_init function. mr_mem_init () is
       defined as
       <programlisting language="c"><![CDATA[
       MR_MEM_INIT ( , __attribute__((constructor,weak)));
       ]]></programlisting>
       in a <filename>metaresc.c</filename>. I.e. this functions is
       a first in a list of <code>constructors</code> due to library
       linkage order and could be replaced on alternative implementation
       at later linkage stages.
     </para>

   </section>
   
   <section xml:id="type-declaration">
     <title>Declaring Types</title>
     
     <section>
       <title>Why special grammar?</title>
       <para>
         The C programming language does not provide metadata for
         types: neither for built-ins, nor for used-defined
         sturtures. For example, in plain C it is impossible to walk
         through the members of the structure, get their names and
         types programmatically. This ability, called type
         introspection, is crucial for data persistence. To perform
         deserialization the application needs to know where to place
         incoming data.
       </para>

       <para>
         To overcome this, the library provides specific grammar for
         declaring types. User-defined types, declared that way, contain
         the necessary metadata, added by the library.
       </para>
     </section>

     <section>
       <title>Declaring structures</title>

       <para>
         In METARESC language the structure is declared using
         <code>TYPEDEF_STRUCT</code> variadic macro, that has variable
         number of arguments. The first argument is an identifier -
         the name of the structure and the rest is the list of field
         declarations, see <xref linkend="decl-fields"/>. Recall the
         example from the previous chapter:

         <programlisting language="c"><xi:include
           href="../../examples/simple_structure.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
       </para>
     </section>

     <section xml:id="decl-unions">
       <title>Declaring unions</title>
       <para>
	 The declaration of the named union type follows the same
	 rules as for the structure. The only syntactic difference is
	 the use of the <code>TYPEDEF_UNION</code> macro. The rest
	 arguments are list of the union members, see <xref
	 linkend="decl-fields"/>. Sample follows:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/named_union.h"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>
       </para>
     </section>
    
     <section>
       <title>Declaring enumerations</title>
       <para>
	 The library allows you to declare metadata-enabled
	 enumerations. This may be used, for example, if you want to
	 walk over enumeration members programmatically from inside
	 the running application. Another example is METARESC
	 itself. If the enumeration is declared using the library
	 language and the fields of the enumeration type present in a
	 structure, then when the instance of the structure is
	 serialized the output may contain readable enumeration
	 constant name for the field value instead of a number. For
	 example, see <xref linkend="marsh-enums"/>.
       </para>
      
       <para>
	 Enumerations are declared using the <code>TYPEDEF_ENUM</code>
	 variadic macro. The first argument is the name of the
	 enumerated type. The rest arguments are considered to be
	 declarations of enumeration.  Declarations have the following
	 form:
        
	 <programlisting language="c">
	   ( name, = value<subscript>opt</subscript>,
	   comment<subscript>opt</subscript>,
	   { pointer-on-user-data }<subscript>opt</subscript>,
	   user-data-type<subscript>opt</subscript>
	   )
	 </programlisting>
        
	 Each enumerator declaration should at least specify the name
	 of the constant. If the declaration only specifies a name,
	 then parentheses may be omitted. The second argument is
	 optional and, if present, specifies the value for enumeration
	 preceded with equals sign. Enumeration constant values obey
	 usual C rules: if the value is not specified, it recieves the
	 incremented value of the previous constant; the first
	 constant recives the value zero if it is not specified
	 explicitly. The following code exemplifies this:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/enums.h"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
        
	 Comment, pointer-on-user-data and user-data-type arguments
	 have the same meaning as in structure member declarations.
       </para>
     </section>
    
     <section xml:id="decl-char-array-type">
       <title>Declaring chars array type</title>
       <para>
	 The library allows to declare types for strings of fixed
	 length. It is a type of char array of fixed length declared
	 like following <code>typedef char
	 char_array_t[8]</code>. This is a special case because this
	 kind of arrays should be serialized as strings, but not as an
	 array of characters. The macro
	 <code>TYPEDEF_CHAR_ARRAY</code> has two mandatory
	 arguments. The first argument is a name of new type, second
	 is a length of the string.
	 <programlisting language="c">
	   TYPEDEF_CHAR_ARRAY (type_name, length)
	 </programlisting>
       </para>
     </section>

     <section xml:id="decl-funcs-type">
       <title>Declaring function type</title>
       <para>
	 Library provides a macro for declaration of function
	 types. <code>TYPEDEF_FUNC</code> gets three mandatory
	 arguments - type name, type of return value and a list of
	 arguments types. Note that C allows accomplish types of the
	 arguments with names. Metaresc declarations must not use
	 names for arguments.
	 
	 <programlisting language="c">
	   TYPEDEF_FUNC (type_name, return_type, (func_args_list))
	 </programlisting>

	 Function types can't be serialized, but library has meta data
	 about return type and types of all arguments. This
	 information could be inspected programmatically. Example follows:
	 <programlisting language="c"><xi:include
	 href="../../examples/function_type.c"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>

	 This sample outputs the following:
	 <programlisting language="c">
{
  .mr_type = MR_TYPE_FUNC_TYPE,
  .size = 8,
  .type = "func_t",
  .attr = "__attribute__ ((aligned (sizeof (int64_t))))",
  .mr_type_effective = MR_TYPE_NONE,
  .size_effective = 0,
  .lookup_by_value = NULL,
  .hash_value = 14201389972600988967,
  .lookup_by_name = {
    .data = NULL,
    .size = 0,
    .alloc_size = 0,
    .ext = {
      NULL,
    },
    .ptr_type = NULL,
  },
  .fields = {
    .data = (mr_fd_t[]){
      {
        .type = "int",
        .name = NULL,
        .hash_value = 0,
        .offset = 0,
        .size = 4,
        .mr_type = MR_TYPE_INT32,
        .mr_type_aux = MR_TYPE_NONE,
        .mr_type_ext = MR_TYPE_EXT_NONE,
        .param = {
          .array_param = {
            .count = 0,
            .row_count = 0,
          },
        },
        .comment = "return value",
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
      {
        .type = "char *",
        .name = NULL,
        .hash_value = 0,
        .offset = 0,
        .size = 8,
        .mr_type = MR_TYPE_STRING,
        .mr_type_aux = MR_TYPE_CHAR,
        .mr_type_ext = MR_TYPE_EXT_NONE,
        .param = {
          .array_param = {
            .count = 0,
            .row_count = 0,
          },
        },
        .comment = /* ref_idx = 48 */ "",
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
      {
        .type = "int",
        .name = NULL,
        .hash_value = 0,
        .offset = 0,
        .size = 4,
        .mr_type = MR_TYPE_INT32,
        .mr_type_aux = MR_TYPE_NONE,
        .mr_type_ext = MR_TYPE_EXT_NONE,
        .param = {
          .array_param = {
            .count = 0,
            .row_count = 0,
          },
        },
        .comment = /* ref_content = 48 */ NULL,
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
      {
        .type = "int",
        .name = NULL,
        .hash_value = 0,
        .offset = 0,
        .size = 4,
        .mr_type = MR_TYPE_INT32,
        .mr_type_aux = MR_TYPE_INT32,
        .mr_type_ext = MR_TYPE_EXT_POINTER,
        .param = {
          .array_param = {
            .count = 0,
            .row_count = 0,
          },
        },
        .comment = /* ref_content = 48 */ NULL,
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
      {
        .type = "double",
        .name = NULL,
        .hash_value = 0,
        .offset = 0,
        .size = 8,
        .mr_type = MR_TYPE_DOUBLE,
        .mr_type_aux = MR_TYPE_NONE,
        .mr_type_ext = MR_TYPE_EXT_NONE,
        .param = {
          .array_param = {
            .count = 0,
            .row_count = 0,
          },
        },
        .comment = /* ref_content = 48 */ NULL,
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
    },
    .size = 560,
    .alloc_size = -1,
    .ext = {
      NULL,
    },
    .ptr_type = NULL,
  },
  .comment = "function type sample",
  .ext = {
    NULL,
  },
  .ptr_type = NULL,
}
	 </programlisting>

       </para>
     </section>

     <section xml:id="decl-typedef-attr">
       <title>Types declaration attributes and meta data</title>
       <para>
	 Macroses <code>TYPEDEF_</code>XXX provides a mechanism for
	 specification of metadata for type itself. One of arguments
	 (at any position) might have prefix <code>ATTRIBUTE</code>.
	 After this key-word there should be a list of metadata in
	 parentheses.
         <programlisting language="c">
	   ATTRIBUTES (
	   type-attributes<subscript>opt</subscript>,
	   comment<subscript>opt</subscript>,
	   { pointer-on-user-data }<subscript>opt</subscript>,
	   user-data-type<subscript>opt</subscript>
	   )
	 </programlisting>
	 
	 <code>type-attributes</code> is an attruibute for type
	 declaration, for example it could be <code>__attribute__
	 ((packed))</code>. This parameter is also saved as a string
	 in type's metadata. <code>comment</code> is an arbitrary text
	 that would be saved as type's metadta.
	 <code>poiner-on-user-data</code> is a void pointer for user
	 data. For serialization of pointer-on-user-data it is
	 possible to specify type of this pointer via
	 <code>user-data-type</code>. This type should be declared by
	 means METARESC.
       </para>
     </section>

     <section xml:id="decl-fields">
       <title>Declaring structure/union fields</title>
       <para>
	 After type name and optional type's attributes fields
	 declaration follows. Field's declaration should be delimitted
	 by comma. Comma after last field is optional.  Fields of the
	 structure may be of standard C types, user-defined types and
	 types, specific to METARESC. Field declarations for standard
	 and user-defined types have following form:
         
         <programlisting language="c">
	   ( type, name,
	   suffix<subscript>opt</subscript>,
	   comment<subscript>opt</subscript>,
	   { pointer-on-user-data }<subscript>opt</subscript>,
	   user-data-type<subscript>opt</subscript>
	   )
	 </programlisting>
        
        The first two arguments are mandatory and specify field type
        and name. Other four arguments are optional. If any of
        optional arguments is used in a declaration, then the previous
        optional arguments must be specified too. That is to have a
        comment you need to specify type suffix as well. To make
        declaring structures more convenient the library allows empty
        type suffixes and comments:
        
        <programlisting language="c"><xi:include
          href="../../examples/suffixes_comments_userdata.h"
          parse="text"
          xmlns:xi="http://www.w3.org/2003/XInclude"
        /></programlisting>
       </para>
       
       <para>
         The type suffix argument is used to declare arrays and
         functions. Think of object declarations in C language. They
         always have a "base" type specifier and a list of
         declarators, each consisting of a variable name and
         additional "directions" like "this is an array" or "this is
         actually a function":
         
         <programlisting language="c">int x, a[3], f(int);</programlisting>
         
         The code line above declares a variable, an array and a
         function. Type suffixes in METARESC work the same way. For
         immediate example of type suffixes see <xref
         linkend="decl-arrays"/> or <xref linkend="decl-pfuncs"/>.
       </para>

       <para>
	 Fields that preceded with key word <code>NONE</code> wil lnot
	 be serialized. Meta information of this field will be
	 incomplete and has type <code>MR_TYPE_VOID</code>
       </para>
       
       <para>
         Note, that the library does not allow declaring more than one
         structure field in a single declaration line. As the result,
         you have to put type prefixes in the "type" argument of a
         field declaration. Here is the example:
         
         <programlisting language="c"><xi:include
           href="../../examples/type_prefixes.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
       </para>
       
       <para>
         The comment and pointer-on-user-data fields are useful if you
         are accessing metadata for yor types programmatically at
         run-time. The comment argument of field declaration is any
         text you may find useful to "attach" to the field. The
         pointer-on-user-data argument is of <code>void*</code>
         type. It is used together with the user-data-type
         argument. There are several options for using
         pointer-on-user-data and user-data-type:
         
         <itemizedlist>
           <listitem><para> Pointer-on-user-data points to statically
           allocated object with external linkage (a global variable,
           for example). In this case user-data-type should be a text
           string, specifying the type of the pointed-to value. Any
           type declared using METARESC grammar is allowed, built-in
           types are not supported.  </para></listitem>
           <listitem><para>The user-data-type argument is unspecified.
           <!-- TODO: or meaningless: how "meaningful" is defined? -->
           In this case pointer-on-user-data is treated by the library
           as an opaque value.
           </para></listitem>
           <listitem><para>The pointer-on-user-data is used for a
           second text field. In this case user-data-type should be
           specified as "string_t".
           </para></listitem>
         </itemizedlist>
       </para>
       
       <para>
         The library provides a convenient way to declare fields of
         built-in types: the simplified grammar. It may be used if the
         field is of basic type (without any type prefixes and
         suffixes) and no comments or user-provided meta-data for the
         field are necessary. The following example contains a
         simplified structure declaration:
         
         <programlisting language="c"><xi:include
           href="../../examples/simplified_grammar.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
         
         The simplified structure field declaration is a set of
         keywords followed by the field name. The recognized keywords
         are:
         
         <itemizedlist>
           <listitem><para> <code>char</code> </para></listitem>
           <listitem><para> <code>int</code> </para></listitem>
           <listitem><para> <code>unsigned</code> </para></listitem>
           <listitem><para> <code>signed</code> </para></listitem>
           <listitem><para> <code>short</code> </para></listitem>
           <listitem><para> <code>long</code> </para></listitem>
           <listitem><para> <code>float</code> </para></listitem>
           <listitem><para> <code>double</code> </para></listitem>
           
           <listitem><para>
             <code>int</code>N<code>_t</code> ( where N is one of 8,
             16, 32, 64 )
           </para></listitem>
           
           <listitem><para>
             <code>uint</code>N<code>_t</code> ( where N is one of 8,
             16, 32, 64 )
           </para></listitem>
           <!-- TODO: support other integer types, like least, fast,
           max, etc. -->
           <listitem><para> <code>volatile</code> </para></listitem>
           <listitem><para> <code>__volatile__</code> and <code>__volatile</code> ( GCC-specific ) </para></listitem>
           <listitem><para> <code>const</code> </para></listitem>
           <listitem><para> <code>__const__</code> and <code>__const</code>( GCC-specific ) </para></listitem>
           
           <listitem><para> <code>string_t</code> ( METARESC-specific ) </para></listitem>
           <listitem><para> <code>long_double_t</code> ( METARESC-specific ) </para></listitem>
         </itemizedlist>
         
         The <code>string_t</code> is a <code>typedef</code> for
         <code>char*</code>. It is necessary to make possible
         declaring a pointer to character string when using simplified
         grammar. <code>long_double_t</code> is a <code>typedef</code> for
         <code>long double</code>.

       </para>
       
       <para>
         For some field types the field declaration grammar is more
         involved. Most notable are anonymous unions and bit-fields.
         Structures may also have fields of METARESC-specific
         types. For more information see <xref
         linkend="decl-anon-union"/>, <xref linkend="decl-bfields"/> and
         <xref linkend="decl-rarrays"/>.
       </para>
     </section>

     <section>
       <title>Declaring basic types</title>
       <para>
         METARESC supports basic types, defined in the Standard. The
         supported types are listed in the following code sample:
	 <!-- _Bool, _Complex, _Decimal128 are not supported yet -->

         <programlisting language="c"><xi:include
           href="../../examples/builtins.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>

         The C language implementation of your choice may also define
         some extended integer types. The extended integer types are
         not supported by the library.
       </para>

       <para>
         METARESC is also able to recognize specified-width integer
         types, which have the same representation as one of standard
         integer types. This works for exact-width, minimum-width,
         fastest, greatest-width types and types for holding pointers:
         
         <programlisting language="c"><xi:include
           href="../../examples/specified_width.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
       </para>
     </section>
    
     <section xml:id="decl-arrays">
       <title>Declaring arrays</title>
       <para>
         To declare a structure field as an array with fixed number of
         elements you may use the third — type suffix — argument of a
         declaration. METARESC is able to recognize one- and two-
         dimensional arrays. A two-dimensional array of integers looks
         like this:
         
         <programlisting language="c"><xi:include
           href="../../examples/arrays.h"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>
         
         Array type suffixes are not compatible with type prefixes. In
         other words, declaring arrays of pointers is not allowed.
         The recommended way to deal with arrays of pointers and
         multidimensional arrays is to declare helper structure types,
         then use them as a type for array items, as in the following
         code sample:
        
        <programlisting language="c"><xi:include
           href="../../examples/multidimensional_arrays.c"
           parse="text"
           xmlns:xi="http://www.w3.org/2003/XInclude"
         /></programlisting>

	Output of this code is the following:
        <programlisting language="c">
space_t space = {
  .planes = {
    {
      .points = {
        {
          {
            .pbox = (box_t[]){
              {
                .name = "some name",
                .creation_time = 1336547701,
              },
            },
          },
          {
            .pbox = NULL,
          },
        },
        {
          {
            .pbox = NULL,
          },
          {
            .pbox = NULL,
          },
        },
      },
    },
    {
      .points = {
        {
          {
            .pbox = NULL,
          },
          {
            .pbox = NULL,
          },
        },
        {
          {
            .pbox = NULL,
          },
          {
            .pbox = NULL,
          },
        },
      },
    },
  },
};
	</programlisting>
       </para>

       <para>
	 There is a special case for arrays of <code>char</code>. By
	 default such fields will be serialized as an array of single
	 characters. For serialization as string you need to use key
	 word <code>CHAR_ARRAY</code> before field
	 declaration. Another option is to declare chars array type as
	 described here <xref linkend="decl-char-array-type"/> and use
	 it as a field type.
       </para>
     </section>
    
     <section xml:id="decl-pfuncs">
       <title>Declaring pointers to functions</title>
       <para>
	 The C language allows you to declare a field of the structure
	 as a pointer to function — and for the sake of completeness
	 METARESC allows this too. From the serialization point of
	 view this has little meaning. The structure type having a
	 pointer-to-function member can be, however, inspected at
	 run-time, just like any other structure declared using the
	 language of the library. Moreover, you can programmatically
	 walk through the signature of the function. This may be
	 helpful for run time type checking.
       </para>
      
       <para>
	 To declare a function pointer just use the type suffix
	 argument of a field declaration and pass a parenthesized list
	 of types. The only difference from a normal function pointer
	 declaration is that you don't use an asterisk and additional
	 parentheses around pointer name:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/function_pointers.c"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>
        
	 The example above prints the following:
	 <programlisting language="c">
{
  .mr_type = MR_TYPE_STRUCT,
  .size = 8,
  .type = "with_f_pointers_t",
  .attr = /* ref_idx = 4 */ "",
  .mr_type_effective = MR_TYPE_NONE,
  .size_effective = 0,
  .lookup_by_value = NULL,
  .hash_value = 5242295550596278467,
  .lookup_by_name = {
    .data = (mr_fd_ptr_t[]){
      {
        .fdp = NULL,
      },
      {
        .fdp = NULL,
      },
      {
        .fdp = /* ref = 24 */ NULL,
      },
    },
    .size = 24,
    .alloc_size = 24,
    .ext = {
      NULL,
    },
    .ptr_type = NULL,
  },
  .fields = {
    .data = (mr_fd_t[]){
      /* ref_idx = 24 */ {
        .type = "char *",
        .name = "pfunc",
        .hash_value = 10734660904406256812,
        .offset = 0,
        .size = 8,
        .mr_type = MR_TYPE_FUNC,
        .mr_type_aux = MR_TYPE_NONE,
        .mr_type_ext = MR_TYPE_EXT_NONE,
        .param = {
          .func_param = {
            .data = (mr_fd_t[]){
              {
                .type = "char *",
                .name = NULL,
                .hash_value = 0,
                .offset = 0,
                .size = 8,
                .mr_type = MR_TYPE_STRING,
                .mr_type_aux = MR_TYPE_CHAR,
                .mr_type_ext = MR_TYPE_EXT_NONE,
                .param = {
                  .array_param = {
                    .count = 0,
                    .row_count = 0,
                  },
                },
                .comment = "return value",
                .ext = {
                  NULL,
                },
                .ptr_type = NULL,
              },
              {
                .type = "int",
                .name = NULL,
                .hash_value = 0,
                .offset = 0,
                .size = 4,
                .mr_type = MR_TYPE_INT32,
                .mr_type_aux = MR_TYPE_NONE,
                .mr_type_ext = MR_TYPE_EXT_NONE,
                .param = {
                  .array_param = {
                    .count = 0,
                    .row_count = 0,
                  },
                },
                .comment = /* ref_content = 4 */ NULL,
                .ext = {
                  NULL,
                },
                .ptr_type = NULL,
              },
            },
            .size = 224,
            .alloc_size = -1,
            .ext = {
              NULL,
            },
            .ptr_type = NULL,
          },
        },
        .comment = /* ref_content = 4 */ NULL,
        .ext = {
          NULL,
        },
        .ptr_type = NULL,
      },
    },
    .size = 112,
    .alloc_size = -1,
    .ext = {
      NULL,
    },
    .ptr_type = NULL,
  },
  .comment = /* ref_content = 4 */ NULL,
  .ext = {
    NULL,
  },
  .ptr_type = NULL,
}
	 </programlisting>

       </para>
     </section>

     <section xml:id="decl-composite">
       <title>Declaring field of composite type and pointers</title>
       <para>
	 Fields that has type declared by means of Metaresc could be
	 defined as any other basic type. The same is true for
	 pointers on composite and basic types. Pointers on structures
	 that are not declared yet should use key word
	 <code>struct</code>. Pointers on pointers and any other
	 higher level of pointers should be declared by means of
	 wrapper types. Sample follows:
	 
	 <programlisting language="c"><xi:include
	 href="../../examples/double_pointer.c"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>

	 This sample produces the following output:
	 <screen><![CDATA[
<?xml version="1.0"?>
<idp>
  <ip_ptr>
    <ip_ptr>
      <ptr>
        <ptr>1234</ptr>
      </ptr>
    </ip_ptr>
  </ip_ptr>
  <ptr>
    <ptr>4321</ptr>
  </ptr>
</idp>
]]></screen>
       </para>
     </section>
    
     <section xml:id="decl-anon-union">
       <title>Declaring anonymous unions</title>
       <para>
	 The C language allows omitting identifiers when declaring
	 structures and unions, this results in a type which can only
	 be reffered to by the declaration of which it is a part.
	 <!-- TODO: add reference §6.7.2.3(5) -->
	 METARESC partially follows this and allows to declare a union
	 member of the structure without having to declare the type
	 for the union first. A union member like this is called
	 <firstterm>anonymous union</firstterm>. The following code
	 sample declares anonymous unions:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/anonymous_unions.c"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>
        
	 As seen from the example, anonymous unions declared using the
	 library language obey normal C rules — their members are
	 accessed as if they were declared right in the structure.

	 Metaresc implementation of anonymous unions creates internal
	 type with the name <code>mr_type_anonymous_union_XXX_t</code>
	 where XXX is a counter place holder. In structure anonymous
	 union replaced on a field of that type. Name of this field
	 could be specified as a first argument for
	 <code>ANON_UNION</code> macro.

         <programlisting language="c">
	   ANON_UNION ( 
	   name<subscript>opt</subscript>,
	   attributes<subscript>opt</subscript>
	   )
	 </programlisting>

	 If name is omitted then it defaults to
	 <code>anon_union</code>. Several anonymous unions inside one
	 structure must have unique names. Macro
	 <code>ANON_UNION</code> might have second argument -
	 attributes of the union, for example
	 <code>__attribute__((aligned((sizeof
	 (int64_t)))))</code>. Meta data of temporary type could be
	 specified via macro <code>END_ANON_UNION</code>. It has the
	 same semantics as all other meta data definitions.
	
         <programlisting language="c">
	   END_ANON_UNION ( 
	   comment<subscript>opt</subscript>,
	   { pointer-on-user-data }<subscript>opt</subscript>,
	   user-data-type<subscript>opt</subscript>
	   )
	 </programlisting>

	 Note that comment for the union might be used for run-time
	 specification of union branch (see <xref
	 linkend="marsh-unions"/>).
       </para>
     </section>
    
     <section xml:id="decl-bfields">
       <title>Declaring bit-fields</title>
       <para>
	 Structures may implement memory-efficient storage of integers
	 by using bit-fields — bit sequences, which reside in standard
	 integer types side-by-side. METARESC language allows you to
	 declare bit-fields of the structure via the
	 <code>BITFIELD</code> macro. It's arguments are similar to
	 any other declarations.
	
	 <programlisting language="c">
	   BITFIELD ( type, name, :width,
	   comment<subscript>opt</subscript>,
	   { pointer-on-user-data }<subscript>opt</subscript>,
	   user-data-type<subscript>opt</subscript>
	   )
	 </programlisting>
	
	 Base type might be any intger type or enum. The structure in
	 the example below has several bit-fields. This makes it
	 possible to access each field individually without having to
	 encode/decode data, yet retains compact representation in
	 computer memory:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/bitfields.h"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>
       </para>
     </section>
    
     <section xml:id="decl-rarrays">
       <title>Declaring RARRAYs</title>
       <para>
	 In addition to the usual types found in C language, the
	 library allows declaring a structure field to be of
	 METARESC-specific RARRAY (Resizable Array) type. There is no
	 widely-accepted idea on how to declare a resizable array in
	 C; most applications use their own patterns and naming
	 conventions. The RARRAY is a resizable array provided by the
	 library. A structure field of RARRAY type may de declared as
	 follows:
        
	 <programlisting language="c"><xi:include
	 href="../../examples/decl_rarray.h"
	 parse="text"
	 xmlns:xi="http://www.w3.org/2003/XInclude"
	 /></programlisting>
        
	 The first declaration argument specifies the type of array
	 items, the second — the name of the field. Those mandatory
	 arguments might be followed by field meta data. If the first
	 argument is <code>employee_t</code>, as shown in example,
	 then the <code>employees</code> member of the structure is a
	 structure itself and has at least the following fields:
        
	 <programlisting language="c"><![CDATA[
	 struct __attribute__((packed)) {
	 employee_t * data;  // pointer to array items
	 int32_t size;       // used space in bytes
	 int32_t alloc_size; // allocated space in bytes
	 mr_ptr_t ext;       // per-instance user data
	 char * ptr_type;    // the name of the pointed-to object type
	 } employees;
	 ]]></programlisting>
        
	 The <code>ext</code> field is intended for additional data
	 you may need to attach to the instance of resizable
	 array. Usage of <code>ext</code> and <code>ptr_type</code>
	 fields is optional. You may safely zeroize the
	 fields. However, to serialize the <code>ext</code> field
	 correctly (if it is non-null), set <code>ptr_type</code> to
	 character string, containing the name of the type of the
	 object the <code>ext</code> field points to.
       </para>
      
       <para>
	 Since RARRAY keyword produces ordinary data structure, you
	 may use its fileds as you see fit. The library, however, will
	 always assume that the memory pointed to by the
	 <code>data</code> field is allocated using the
	 <code>MR_MALLOC</code> macro. When loading data from external
	 source, you must use <code>MR_FREE</code> to free the memory,
	 occupied by resizable array items ( which the
	 <code>data</code> member points to ), when the array is no
	 longer necessary.
       </para>
     </section>
     
   </section>
  
   <section xml:id="data-persistence">
     <title>Data Persistence</title>
    
     <section>
       <title>Overview</title>
       <para>
        Among various applications of metadata, data persistence — the
        ability to save objects from the memory into a storage
        external to the program and successfully restore them later,
        possibly in a different program invocation — is probably the
        most popular one. METARESC supports data persistence
        out-of-box, providing tools for serializing to and
        de-serializing from multiple data representation formats. The
        supported formats are: XML, JSON, C-init, SCM (Scheme-like
        notation) and XDR. They are described in details later in this
        guide. The XML, JSON, C-init and SCM are textual formats and
        the XDR is a binary format.
      </para>
      
      <para>
        For each textual serialization format there is a macro named
        like <code>MR_SAVE_</code>XXX, where XXX is a suffix, which
        specifies the desired data representation. A macro like that
        accepts two arguments: the name of the serializable type and a
        pointer to the variable of that type to be serialized. This
        macro validates at compile time that type specified for
        serialization matches type of provided pointer. The return
        value is a pointer to the character string. Is is allocated
        dynamically and must be released using the
        <code>MR_FREE</code> library macro. The following is an
        example of serializing data to XML:
        
        <programlisting language="c"><xi:include
          href="../../examples/basic.c"
          parse="text"
          xmlns:xi="http://www.w3.org/2003/XInclude"
        /></programlisting>
        
        If the serialization fails, the returned value is
        <code>NULL</code>. Advanced error handling described in
        separate section <xref linkend="error-handling"/>.
      </para>
      
      <para>
        For de-serializing data from each textual format there is a
        macro <code>MR_LOAD_</code>XXX. It might be called with two or
        three arguments. Based on number of arguments return value is
        different. Macro with three arguments take a type name, a
        pointer to the source string and a pointer to the variable
        that will receive the loaded value. The returned value is an
        <code>int</code>, which is zero if loading failed and non-zero
        otherwise.  The usage looks like the following:
        
        <programlisting language="c"><xi:include
          href="../../examples/deserialization_3_args.c"
          parse="text"
          xmlns:xi="http://www.w3.org/2003/XInclude"
        /></programlisting>

	The same macro with two arguments returns object of
	deserialized type and takes type name and pointer to the
	source string. Load errors could be catched by means of <xref
	linkend="error-handling"/>. Usage example follows:
	
        <programlisting language="c"><xi:include
          href="../../examples/deserialization_2_args.c"
          parse="text"
          xmlns:xi="http://www.w3.org/2003/XInclude"
        /></programlisting>
      </para>
      
    </section>
    
    <section>
      <title>Marshalling supported types</title>
      
      <para>
        This section describes the behavior of the library related to
        data marshalling, which does not depend on the particular
        representation format.
      </para>
    </section>
	
    <section>
      <title>Marshalling structures and basic types</title>
      <para>
	When saving a structure, constisting of fields of basic types,
	the library saves the name and value of each field in the
	order of declaration. The composition of structures, e.g. when
	a structure object being serialized contains a field of
	structure type, is handled by recursing into the field and
	saving all sub-field names and values. The recursion depth is
	exactly defined by the declaration of the type. To have an
	example, consider the following declaration:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_structures_basic_types.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
	
	If an instance of <code>basics_t</code> is serialized to XML,
	it may look like this:
          
	<programlisting language="xml"><![CDATA[<?xml version="1.0"?>
<b>
  <c>Z</c>
  <uli>123</uli>
  <fl>
    <f>0.3000000</f>
    <ld>3.1400000000000001243</ld>
  </fl>
</b>]]></programlisting>
          
	<!-- TODO: add example of composition in "declarations"
	     section -->
      </para>
    </section>
      
    <section xml:id="marsh-enums">
      <title>Marshalling enumerations</title>
      <para>
	If the field of the structure has enumerated type, then when
	serializing the field into a textual representation METARESC
	uses the readable enumeration member name instead of numerical
	value. If saved value is not listed in enumeration, then it
	will be saved as a numerical value. For instance, if declared
	like this:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_enumerations.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
          
	The variable of <code>screen_t</code> type may have the
	following XML representation:
          
	<programlisting language="xml"><![CDATA[<?xml version="1.0"?>
<cons25>
  <width>80</width>
  <height>25</height>
  <bg>BLACK</bg>
  <fg>WHITE</fg>
</cons25>]]></programlisting>
      </para>
    </section>
      
    <section>
      <title>Marshalling arrays</title>
      <para>
	If the field of the structure is an array, then during
	serialization the library saves each element's value. The
	process starts from the element with zero index. The elements
	are named after the array field. As usual, there is an
	example. The declaration looks like this:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_arrays.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
	
	And the XML output looks like this:
          
	<programlisting language="xml"><![CDATA[<?xml version="1.0"?>
<a>
  <a>
    <a>11</a>
    <a>17</a>
    <a>23</a>
  </a>
</a>
<?xml version="1.0"?>
<a2d>
  <a>
    <a>
      <a>1</a>
      <a>2</a>
    </a>
    <a>
      <a>3</a>
      <a>4</a>
    </a>
  </a>
</a2d>]]>
	</programlisting>
	Two-dimensional arrays saves as an array of rows. Each row is
	one-dimnsional array.
      </para>
    </section>
      
    <section xml:id="marsh-unions">
      <title>Marshalling unions</title>
      <para>
	The union is very similar to a structure with a constraint
	that only the field that was most recently written may be read
	<footnote><para>ISO/IEC 9899:1999 J1.1</para></footnote>. This
	allows compilers to optimize memory consumption of the program
	and don't store all the fields of the union in the memory at
	the same time <footnote><para>see C99 6.7.2.1p5 and
	6.7.2.1p14</para></footnote>.  It's tricky to serialize the
	union, since C doesn't provide any means to determine which
	field was most recently written. At present, METARESC relies
	on the behavior of GCC, which allows cross-reading of union
	members<footnote><para>The library code is based on the
	assumption that all side-effects of statements that write to
	the union are completed before the serialization takes
	place.</para></footnote>. By default library serializes the
	value of the first union member. There is a convention that
	allows to choose union branch at the time of
	serialization. Discriminator value should be stored in
	structure at the same lavel as union. Name of the
	discriminator field should be specified in meta data comment
	of the union. Discriminator field could be of the following
	types: integer, bit-field, string, static string, enumeration
	or pointer on one of this types. Value of discriminator field
	interpreted in the following manner:
	<itemizedlist>
	  <listitem><para>
	    integers, bit-fields: interpreted as union branch index
	    counted from zero.
	  </para></listitem>
	  <listitem><para>
	    strings, static strings: interpreted as a union branch name.
	  </para></listitem>
	  <listitem><para>
	    enumeration: definitions of enumeration values should
	    contain meta data comment with the name of the
	    designated union branch.
	  </para></listitem>
	</itemizedlist>
      </para>
        
      <para>
	So then, having the sample like this:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_unions.c"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
          
	You may expect the following output on GCC, regardless of what
	member was most recently written:
          
	<programlisting language="xml"><![CDATA[
<?xml version="1.0"?>
<u>
  <union_val>
    <uc_array>
      <uc_array>219</uc_array>
      <uc_array>15</uc_array>
      <uc_array>73</uc_array>
      <uc_array>64</uc_array>
    </uc_array>
  </union_val>
  <union_discriminator>UD_UC_ARRAY</union_discriminator>
</u>
]]>
	</programlisting>
          
	This, of course, also depends on the language
	implementation. For example, there may be more
	<code>char</code>s in a <code>float</code>.
      </para>
    </section>
      
    <section>
      <title>Marshalling pointers</title>
      <para>
	Pointers differ from numeric types in that the value a pointer
	holds is rarely interesting per se. You rather use a pointer
	to access a pointed-to object and the value of the pointer is
	typically a memory address of that object. Memory addresses
	are meaningless from the serialization perspective — when
	objects are de-serialized in other program invocation the
	saved address may point to the memory of an unrelated object
	or to the location where there is no object at all.
      </para>
        
      <para>
	That's why METARESC takes a specific approach for pointers,
	called "deep pointer serialization": when a structure field of
	pointer type is encountered, the library examines the value
	and if it points to an object of metadata-enabled type, then
	this pointed-to object is also serialized. This process is
	recursive.
      </para>
        
      <para>
	During de-serialization of a field of pointer type METARESC
	allocates memory for a pointed-to object and recursively
	restores it. That is pointer values are not preserved when
	objects are saved and restored, but their meaning is.
      </para>
        
      <para>
	The special cases for deep pointer serialization are duplicate
	pointers, that is more than one pointer to the same object,
	and cycles in chains of pointers. The library keeps a track of
	already visited objects during serialization. In presence of
	multiple pointers to the same object the latter is serialized
	only once and assigned an id, which is used to serialize other
	pointers to that object. For the same reason pointer loops are
	never an issue.
      </para>
        
      <para>
	Note, that uniqueness of objects is only examined for a single
	serialization session. If you have two structures, containing
	pointers to the same third object, and serialize them
	independently, METARESC will create four distinct objects on
	de-serialization. The recommended way of preserving the
	uniqueness is gathering all the data into a single structure
	and serializing it in a single step.
      </para>
        
      <para>
	Deep pointer serialization is only possible if the pointed-to
	object is of serializable type, i.e. declared using METARESC
	grammar. If the field of the structure points to the object
	which is not serializable, then pointer value is not
	serialized at all.
      </para>
        
      <para>
	The following is an example of deep pointer serialization with
	duplicate pointers and a pointer to type lacking
	metadata. Given the declarations like this:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_pointers.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
          
	And the program, which uses them:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_pointers.c"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
          
	The serialized data may look like this:
          
	<programlisting language="c"><![CDATA[
<?xml version="1.0"?>
<p>
  <server_a>
    <server_a>
      <id>3</id>
      <address>305402420</address>
      <port>80</port>
    </server_a>
  </server_a>
  <server_b ref="9"/>
  <f/>
  <fallback>
    <fallback ref_idx="9">
      <id>11</id>
      <address>1126253345</address>
      <port>443</port>
    </fallback>
  </fallback>
</p>]]>
	</programlisting>
          
	Note that the field <code>f</code> is not assigned a value and
	fields <code>server_b</code> and <code>fallback</code> both
	point to the same object.
      </para>
    </section>
      
    <section>
      <title>Marshalling pointers to functions</title>
      <para>
	Unlike instances of structures, functions are not tracked by
	the library. That's why pointers to functions are always
	excluded from serialization. Given the following declarations:
          
	<programlisting language="c"><xi:include
	href="../../examples/marshalling_pointers_to_functions.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
	
	You may expect output like this:
          
	<programlisting language="c"><![CDATA[
<?xml version="1.0"?>
<s>
  <value>7</value>
</s> ]]>
	</programlisting>
          
	The field <code>func</code> is not present in the XML file and
	the intended usage of pointers-to-functions metadata is
	reading the data programmatically.
      </para>
    </section>
      
    <section>
      <title>Marshalling bit-fields</title>
      <para>
	The sole purpose of using bit-fields is to minimize the memory
	occupied by small integers or enums. Serialization formats are
	often verbose and the product of serialization is better
	compressed by archiving the entire stream.  Based on that,
	bit-fields are serialized by METARESC as if they were distinct
	variables.
      </para>
        
      <para>
	This is exemplified by following declarations:
          
	<programlisting language="c"><xi:include
	href="../../examples/bitfields.c"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
          
	The serialization may produce the following XML output:
          
	<programlisting language="xml"><![CDATA[
sizeof (date_t) = 4
<?xml version="1.0"?>
<today>
  <year>2012</year>
  <month>SEP</month>
  <day>30</day>
  <hour>10</hour>
  <minute>59</minute>
</today>
]]>
	</programlisting>
      </para>
    </section>
      
    <section>
      <title>Marshalling RARRAYs</title>
      <para>
	The resizable arrays, provided by the library, are serialized
	as a structure presented in C: serialization starts with block
	<code>data</code> and followed by the rest of
	<code>rarray_t</code> fields: <code>size</code>,
	<code>alloc_size</code>, <code>ext</code>,
	<code>ptr_type</code>.  Block <code>data</code> contains list
	of entities just like fixed size arrays. The traversal starts
	form zero index. So that, having a declaration like this:
          
	<programlisting language="c"><xi:include
	href="../../examples/decl_rarray.h"
	parse="text"
	xmlns:xi="http://www.w3.org/2003/XInclude"
	/></programlisting>
	
	You may expect the following output:
          
	<programlisting language="xml"><![CDATA[
<?xml version="1.0"?>
<firm>
  <name>Gen-sys</name>
  <employees>
    <data>
      <employees>
        <firstname>Will</firstname>
        <lastname>Rodman</lastname>
        <salary>200000</salary>
      </employees>
      <employees>
        <firstname>Static</firstname>
        <lastname>Jacobs</lastname>
        <salary>250000</salary>
      </employees>
      <employees>
        <firstname>Robert</firstname>
        <lastname>Franklin</lastname>
        <salary>170000</salary>
      </employees>
    </data>
    <size>72</size>
    <alloc_size>0</alloc_size>
    <ext>
      <ptr isnull="true"/>
    </ext>
    <ptr_type isnull="true"/>
  </employees>
</firm>
]]>
	</programlisting>
          
	The only trick here is to remember that the <code>size</code>
	and <code>alloc_size</code> fields of a resizable array are in
	bytes. To correctly serialize the variable in the example
	above the program set the <code>size</code> member to <code>3
	* sizeof(employee_t)</code>.
      </para>
    </section>
      
    <section>
      <title>Input-output Formats</title>
      
      <section>
        <title>XML format</title>
        <para>
          METARESC supports the XML format as defined in <link
          xlink:href="http://www.w3.org/TR/2008/REC-xml-20081126/">W3C
          XML 1.0 specification</link>. The <code>MR_SAVE_XML</code>
          macro is used for serializing into XML. It accepts two
          arguments: the name of the type and the pointer to the
          variable. First argument specifies the type of the variable
          to be serialized. The returned value is a dynamically
          allocated character string, containing the XML
          representation of your data. The string is
          zero-terminated. If serialization fails, the library returns
          NULL. The following code sample saves data in XML format:
          
          <programlisting language="c"><xi:include
            href="../../examples/basic.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          There are two macros for de-serializing data from XML. Both
          are named <code>MR_LOAD_XML</code>; the library
          distinguishes one from another by the number of
          arguments. First version accepts two arguments: the name of
          the type to be loaded and the text string representing the
          data in XML. The loaded data is returned by value, the value
          may be assigned to the variable of the specified type. The
          following code sample uses this form of macro:
          <!-- TODO: Error handling! -->
          <programlisting language="c"><xi:include
            href="../../examples/deserializing_xml.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          De-serialization usually deals with data external to the
          application. For this reason the process may fail if the
          data is corrupted. To simplify error handling, the library
          provides the second form of macro, having three
          arguments. The additional argument points to the variable
          that will receive the loaded data. The returned value is a
          number: zero for failure and non-zero for success. The usage
          is exemplified in the following code:
          
          <programlisting language="c"><xi:include
            href="../../examples/deserialization_3_args.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          When loading data, METARESC have to parse the external
          representation and fill your data structure with values. Of
          course, an arbitrary XML document may not be used for this,
          because it has to match your C data structures. Naturally,
          any document serialized by the library is loadable. If the
          document to be read is generated externally or the document
          produced by METARESC is to be processed by another software,
          it is helpful to know how C data structures map to XML. The
          following is a list of rules, used by the library:
          
          <itemizedlist>
            <listitem><para> The root element is named after the
            variable that was serialized. When de-serializing the data
            the name of the root element is ignored.
            </para></listitem>
            
            <listitem><para> If the element represents a structure (as
            the root element does), it has a child element for each
            field<footnote><para>Function pointers being a notable
            exception</para></footnote>. These sub-elements are named
            after the fields of the structure. </para></listitem>
            
            <listitem><para> Values of basic types, enumerated types
            and bit-fields are represented by element text.
            </para></listitem>
            
            <listitem><para> Fields of array type have sub-elements,
            one for each array element. The sub-elements have the same
            name as the array variable.
            </para></listitem>
            
            <listitem><para> Unions are serialized like structures,
            however only the first union member is serialized.
            </para></listitem>
            
            <listitem><para> Pointer field is represented by the
            element, which may have a child element. The child element
            has the same name as the pointer field and represents the
            value of the pointed-to element. In presence of duplicate
            pointers the child element may have a <code>ref_idx</code>
            attribute. In this case some pointer field may be
            represented by an empty element with a <code>link</code>
            attribute. This is used to preserve object uniqueness and
            tie duplicate pointers together.
            </para></listitem>
          </itemizedlist>
        </para>
      </section>
      
      <section>
        <title>JSON format</title>
        <para>
          The JSON textual data format is formally defined in <link
          xlink:href="http://www.ietf.org/rfc/rfc4627.txt">RFC
          4627</link>. METARESC supports saving to and loading from
          this format. Serialization is performed by the
          <code>MR_SAVE_JSON</code> macro. It's arguments are the name
          of the type and a pointer to the variable of that type. The
          macro is used in the following code sample:
          
          <programlisting language="c"><xi:include
            href="../../examples/save_json.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          There is the <code>MR_LOAD_JSON</code> macro for
          de-serializing JSON data. The version with two arguments
          accepts the name of the type and the character string with
          JSON data. The returned value may be used to initialize
          variable of the specified type. The version with three
          arguments additionally accepts a pointer to the variable,
          where the loaded data is to be written. The returned value
          is non-zero for success and zero for failure. The following
          code sample exemplifies this:
          
          <programlisting language="c"><xi:include
            href="../../examples/load_json.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          METARESC uses following rules to map C language objects
          to JSON:
          
          <itemizedlist>
            <listitem><para>
              Structures are represented by JSON objects.
            </para></listitem>
            <listitem><para>
              Integer and floating-point types are represented by JSON
              numbers. <!-- TODO: what about 'char'? -->
            </para></listitem>
            <listitem><para>
              Enumeration constant values are represented by JSON strings.
            </para></listitem>
            <listitem><para>
              Arrays are represented by JSON arrays.
            </para></listitem>
            <listitem><para>
              Pointers to characters are represented by JSON strings.
            </para></listitem>
            <listitem><para>
              Bit-fields are represented by JSON numbers.
            </para></listitem>
            <listitem><para>
              RARRAYs are represented by JSON arrays.
            </para></listitem>
          </itemizedlist>
        </para>
      </section>
      
      <section>
        <title>C-init format</title>
        <para>
          The C-init format is a METARESC-specific data format, which
          has the same grammar as initializer-lists in C language
          <footnote><para>see ISO/IEC 9899:1999 §6.7.8 for formal
          grammar definition</para></footnote>. You may need this
          format for two reasons. First, it may feel more readable if
          you are used to the C language. Second, the text produced by
          serialization may be pasted right into the source code of
          the program and used as initializer for a variable. This is
          a handy way to pre-calculate some data and compile it into
          the executable file to provide faster application start-up.
        </para>
        
        <para>
          The serialization is performed by the
          <code>MR_SAVE_CINIT</code> macro. It accepts the name of the
          type and a pointer to the variable of that type. The
          returned value is a pointer to the character string in the
          case of success and <code>NULL</code> in the case of
          failure. The macro is used in the following code sample:
          
          <programlisting language="c"><xi:include
            href="../../examples/save_cinit.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          De-serialization is performed by the
          <code>MR_LOAD_CINIT</code> macro, which has two forms. The
          first accepts the name of the type and pointer to the
          character string. The returned value has the specified type
          and may be used to directly initialize a variable of that
          type. The second form takes additional argument — pointer to
          the variable that receives the de-serialized value. The
          returned value is non-zero in case of success and zero in
          the case of failure. The following example invokes both
          forms of the macro:
          
          <programlisting language="c"><xi:include
            href="../../examples/load_cinit.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
          
          The representation for this format is not described here,
          because serialization into C-init produces the same text as
          you would write to initialize the structure in C source
          code.
        </para>
      </section>
      
      <section>
        <title>SCM format</title>
        <para>
          The SCM is also a METARESC-specific data representation
          format. It is intended for programs written in Scheme
          language as it has compatible grammar. Serialization is
          performed by the <code>MR_SAVE_SCM</code> macro, which
          accepts the name of the type to be serialized and the
          pointer to the variable, which provides the data:
          
          <programlisting language="c"><xi:include
            href="../../examples/save_scm.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        
        <para>
          There is a macro <code>MR_LOAD_SCM</code> for loading data
          in SCM format. It has two forms: with two and three
          arguments. The two-argument form accepts a name of the type
          and a pointer to the character string with SCM text. The
          returned value has the type, specified by the first
          argument, and may be used to initialize a variable of that
          type. The second form accepts an extra argument, which
          points to the variable that is to receive the loaded
          value. The return value indicates success or failure and may
          be non-zero and zero, respectively. The usage is exemplified
          by the following code:
          
          <programlisting language="c"><xi:include
            href="../../examples/load_scm.c"
            parse="text"
            xmlns:xi="http://www.w3.org/2003/XInclude"
          /></programlisting>
        </para>
        <!-- TODO: rules for mapping from C to SCM -->
      </section>
      
      <section>
        <title>XDR format</title>
        <para />
      </section>
      
    </section>
    
  </section>
  
  <section xml:id="metadata-tech">
    <title>Accessing metadata</title>
    
    <section>
      <title>Type descriptors</title>
      <para />
    </section>
    
    <section>
      <title>Obtaining field types</title>
      <para />
    </section>
    
    <section>
      <title>Getting and setting field values</title>
      <para />
    </section>
    
    <section>
      <title>Type information for pointers to functions</title>
      <para />
    </section>
    
    <section>
      <title>Type information for arrays</title>
      <para />
    </section>
    
    <section>
      <title>Type information for enumerated types</title>
      <para />
    </section>
    
  </section>
  
  <section xml:id="error-handling">
    <title>Advanced error handling</title>
    
    <section>
      <title>Verbosity levels</title>
      <para />
    </section>
  </section>
  
  <appendix>
    <title>
      Effects of separate generation of declarations and metadata
    </title>
    
    <para>
      <informaltable>
        <tgroup cols="2" align="left" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Number of files</entry>
              <entry>Simple (build/start/size)</entry>
              <entry>Optimized (build/start/size)</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>0.67 / 0.00 / 108.3 k</entry>
              <entry>0.59 / 0.00 / 5.0 k</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>3.52 / 0.00 / 119.0 k</entry>
              <entry>3.17 / 0.00 / 6.0 k</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>32.63 / 0.01 / 236.0 k</entry>
              <entry>29.36 / 0.00 / 15.3 k</entry>
            </row>
            <row>
              <entry>50</entry>
              <entry>16.21 / 0.00 / 172.1 k</entry>
              <entry>15.12 / 0.00 / 10.1 k</entry>
            </row>
            <row>
              <entry>500</entry>
              <entry>157.30 / 0.09 / 777.7 k</entry>
              <entry>146.58 / 0.00 / 56.7 k</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </para>
  </appendix>
  
</article>
